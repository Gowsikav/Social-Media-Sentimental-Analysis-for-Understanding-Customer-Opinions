import requests
from bs4 import BeautifulSoup
import pandas as pd
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import emoji

nltk.download('vader_lexicon')

def preprocess_text(text):
    text = emoji.demojize(text)
    return text

def sentiment_Vader(text):
    over_all_polarity = sid.polarity_scores(text)
    if over_all_polarity['compound'] >= 0.05:
        return "positive"
    elif over_all_polarity['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

url = 'https://www.flipkart.com/patlani-style-embroidered-bollywood-net-saree/product-reviews/itmce2a1f39654f5?pid=SARFSA6VYGGKCSF7&lid=LSTSARFSA6VYGGKCSF7QZEKGY&marketplace=FLIPKART'

response = requests.get(url)
content = response.content

soup = BeautifulSoup(content, 'html.parser')

reviews_container = soup.find('div', {'class': '_1YokD2 _3Mn1Gg col-9-12'})

if reviews_container is None:
    print("Error: Reviews container not found.")
    exit()

review_divs = reviews_container.find_all('div', {'class': '_6K-7Co'})

reviews = []

for review_div in review_divs:
    review_text = review_div.get_text().strip()
    preprocessed_text = preprocess_text(review_text)
    reviews.append(preprocessed_text)

if not reviews:
    print("Error: No reviews found.")
    exit()

data = pd.DataFrame({'review': reviews})

data.to_excel('reviews.xlsx', index=False)

sid = SentimentIntensityAnalyzer()

data['polarity'] = data['review'].apply(lambda review: sentiment_Vader(review))


data.to_excel('sentiment_result.xlsx', index=False)


print("Sentiment analysis completed and results saved to 'sentiment_result.xlsx'.")


 

#VADER tool (Valence Aware Dictionary and Sentiment Reasoner) 
#lexicon-based approach - predefined algorithm
#lexicon is word range from -1 to +1
#it takes input as text and also emoji into text form




produce the output in xl sheet
----------------------------------------------------------------



import requests
from bs4 import BeautifulSoup
import pandas as pd
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import emoji
import matplotlib.pyplot as plt

nltk.download('vader_lexicon')

# Function to preprocess text (including handling emojis)
def preprocess_text(text):
    # Convert emojis to text representations
    text = emoji.demojize(text)
    return text

# Function to perform sentiment analysis using VADER
def sentiment_Vader(text):
    over_all_polarity = sid.polarity_scores(text)
    if over_all_polarity['compound'] >= 0.05:
        return "positive"
    elif over_all_polarity['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

# Define the URL of the webpage containing the reviews
url = 'https://www.flipkart.com/wipro-gd203-heavy-weight-1200-w-dry-iron/product-reviews/itm73706d23adb97?pid=IRNGHJ3ZYXDVXGGE&lid=LSTIRNGHJ3ZYXDVXGGESKXJ0P&marketplace=FLIPKART'

# Send a GET request to fetch the webpage content
response = requests.get(url)
content = response.content

# Parse the HTML content using BeautifulSoup
soup = BeautifulSoup(content, 'html.parser')

# Find the reviews container
reviews_container = soup.find('div', {'class': '_1YokD2 _3Mn1Gg col-9-12'})

# Check if the reviews container is found
if reviews_container is None:
    print("Error: Reviews container not found.")
    exit()

# Find all individual review elements within the reviews container
review_divs = reviews_container.find_all('div', {'class':'t-ZTKy'})

# List to store preprocessed reviews
reviews = []

# Iterate over each review element and extract the review text
for review_div in review_divs:
    # Extract the review text
    review_text = review_div.get_text().strip()
    # Preprocess the review text
    preprocessed_text = preprocess_text(review_text)
    # Append the preprocessed review text to the list of reviews
    reviews.append(preprocessed_text)

# Check if any reviews were found
if not reviews:
    print("Error: No reviews found.")
    exit()

# Create a DataFrame to store the reviews
data = pd.DataFrame({'review': reviews})

# Save the reviews to an Excel file
data.to_excel('reviews.xlsx', index=False)

# Initialize the VADER sentiment analyzer
sid = SentimentIntensityAnalyzer()

# Perform sentiment analysis on each review and add the results to the DataFrame
data['polarity'] = data['review'].apply(lambda review: sentiment_Vader(review))

# Save the sentiment analysis results to an Excel file
data.to_excel('sentiment_result.xlsx', index=False)

# Plotting the sentiment distribution
sentiment_counts = data['polarity'].value_counts()
sentiment_counts.plot(kind='bar')
plt.title('Sentiment Distribution')
plt.xlabel('Sentiment')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.show()




produe output in graph
--------------------------------------------------



import requests
from bs4 import BeautifulSoup
import pandas as pd
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import emoji
import time

# Download the VADER lexicon if not already downloaded
nltk.download('vader_lexicon')

# Function to preprocess text (convert emojis to text representations)
def preprocess_text(text):
    return emoji.demojize(text)

# Function to perform sentiment analysis using VADER
def sentiment_vader(text):
    sid = SentimentIntensityAnalyzer()
    polarity_scores = sid.polarity_scores(text)
    if polarity_scores['compound'] >= 0.05:
        return "positive"
    elif polarity_scores['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

# Function to scrape reviews from a single page
def scrape_reviews(url):
    print("Scraping reviews from:", url)
    response = requests.get(url)
    content = response.content
    soup = BeautifulSoup(content, 'html.parser')
    reviews_container = soup.find('div', {'class': '_1YokD2 _3Mn1Gg col-9-12'})
    if reviews_container is None:
        print("No reviews container found.")
        return []
    review_divs = reviews_container.find_all('div', {'class': 't-ZTKy'})
    if not review_divs:
        print("No reviews found on this page.")
        return []
    reviews = []
    for review_div in review_divs:
        review_text = review_div.get_text().strip()
        preprocessed_text = preprocess_text(review_text)
        reviews.append(preprocessed_text)
    return reviews

# Function to scrape reviews from multiple pages
def scrape_flipkart_reviews(product_url, num_pages):
    all_reviews = []
    for page in range(1, num_pages + 1):
        url = f"{product_url}&page={page}"
        reviews = scrape_reviews(url)
        if not reviews:
            print("Stopping further scraping.")
            break
        all_reviews.extend(reviews)
        time.sleep(2)  # Add a delay to avoid hitting Flipkart's servers too frequently
    return all_reviews

# Product URL and number of pages to scrape
product_url = 'https://www.flipkart.com/wipro-gd203-heavy-weight-1200-w-dry-iron/product-reviews/itm73706d23adb97?pid=IRNGHJ3ZYXDVXGGE&lid=LSTIRNGHJ3ZYXDVXGGESKXJ0P&marketplace=FLIPKART'
num_pages = 10

# Scrape reviews from Flipkart
all_reviews = scrape_flipkart_reviews(product_url, num_pages)

if not all_reviews:
    print("Error: No reviews found.")
    exit()

# Create a DataFrame to store the reviews
data = pd.DataFrame({'review': all_reviews})

# Perform sentiment analysis on the reviews
data['polarity'] = data['review'].apply(lambda review: sentiment_vader(review))

# Save the sentiment analysis results to an Excel file
result_data = data.to_excel('flipkart_reviews_sentiment.xlsx')

# Print a message indicating the analysis is complete
print("Sentiment analysis completed. Results saved to flipkart_reviews_sentiment.xlsx.")


produce the product reviews in xl sheet
-----------------------------------------------------------------

import requests
from bs4 import BeautifulSoup
import pandas as pd
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import emoji
import time
import matplotlib.pyplot as plt

# Download the VADER lexicon if not already downloaded
nltk.download('vader_lexicon')

# Function to preprocess text (convert emojis to text representations)
def preprocess_text(text):
    return emoji.demojize(text)

# Function to perform sentiment analysis using VADER
def sentiment_vader(text):
    sid = SentimentIntensityAnalyzer()
    polarity_scores = sid.polarity_scores(text)
    if polarity_scores['compound'] >= 0.05:
        return "positive"
    elif polarity_scores['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

# Function to scrape reviews from a single page
def scrape_reviews(url):
    response = requests.get(url)
    content = response.content
    soup = BeautifulSoup(content, 'html.parser')
    reviews_container = soup.find('div', {'class': '_1YokD2 _3Mn1Gg col-9-12'})
    if reviews_container is None:
        return []
    review_divs = reviews_container.find_all('div', {'class': 't-ZTKy'})
    if not review_divs:
        return []
    reviews = []
    for review_div in review_divs:
        review_text = review_div.get_text().strip()
        preprocessed_text = preprocess_text(review_text)
        reviews.append(preprocessed_text)
    return reviews

# Function to scrape reviews from multiple pages
def scrape_flipkart_reviews(product_url, num_pages):
    all_reviews = []
    for page in range(1, num_pages + 1):
        url = f"{product_url}&page={page}"
        reviews = scrape_reviews(url)
        if not reviews:
            break
        all_reviews.extend(reviews)
        time.sleep(1)  # Reduced delay to 1 second
    return all_reviews

# Product URL and number of pages to scrape
product_url = 'https://www.flipkart.com/wipro-gd203-heavy-weight-1200-w-dry-iron/product-reviews/itm73706d23adb97?pid=IRNGHJ3ZYXDVXGGE&lid=LSTIRNGHJ3ZYXDVXGGESKXJ0P&marketplace=FLIPKART'
num_pages = 10

# Scrape reviews from Flipkart
all_reviews = scrape_flipkart_reviews(product_url, num_pages)

if not all_reviews:
    print("Error: No reviews found.")
    exit()

# Create a DataFrame to store the reviews
data = pd.DataFrame({'review': all_reviews})

# Perform sentiment analysis on the reviews
data['polarity'] = data['review'].apply(lambda review: sentiment_vader(review))

# Plot the sentiment distribution
sentiment_counts = data['polarity'].value_counts()
plt.bar(sentiment_counts.index, sentiment_counts.values, color=['green', 'red', 'gray'])
plt.xlabel('Sentiment')
plt.ylabel('Number of Reviews')
plt.title('Sentiment Analysis')

# Add suggestions as annotations on the plot
suggestions = {
    'positive': 'Highly recommended!',
    'negative': 'Improvement needed.',
    'neutral': 'Mixed reviews.'
}

for i, count in enumerate(sentiment_counts.values):
    sentiment = sentiment_counts.index[i]
    suggestion = suggestions.get(sentiment, 'No suggestion')
    plt.text(i, count, f'{count} reviews\n{suggestion}', ha='center', va='bottom')

# Display the plot
plt.show()


produce the suggestion in graph itself above the bar for three
----------------------------------------------------------------


import requests
from bs4 import BeautifulSoup
import pandas as pd
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import emoji
import time
import matplotlib.pyplot as plt

# Download the VADER lexicon if not already downloaded
nltk.download('vader_lexicon')

# Function to preprocess text (convert emojis to text representations)
def preprocess_text(text):
    return emoji.demojize(text)

# Function to perform sentiment analysis using VADER
def sentiment_vader(text):
    sid = SentimentIntensityAnalyzer()
    polarity_scores = sid.polarity_scores(text)
    if polarity_scores['compound'] >= 0.05:
        return "positive"
    elif polarity_scores['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

# Function to generate a single suggestion based on overall sentiment
def generate_single_suggestion(sentiment):
    suggestions = {
        'positive': 'Highly recommended! This product seems to have great feedback.',
        'negative': 'Some customers had issues with this product. Consider reading the negative reviews before making a decision.',
        'neutral': 'Opinions on this product vary. You may want to explore further to make an informed choice.'
    }
    return suggestions.get(sentiment, 'No suggestion')

# Function to scrape reviews from a single page
def scrape_reviews(url):
    response = requests.get(url)
    content = response.content
    soup = BeautifulSoup(content, 'html.parser')
    reviews_container = soup.find('div', {'class': '_1YokD2 _3Mn1Gg col-9-12'})
    if reviews_container is None:
        return []
    review_divs = reviews_container.find_all('div', {'class': 't-ZTKy'})
    if not review_divs:
        return []
    reviews = []
    for review_div in review_divs:
        review_text = review_div.get_text().strip()
        preprocessed_text = preprocess_text(review_text)
        reviews.append(preprocessed_text)
    return reviews

# Function to scrape reviews from multiple pages
def scrape_flipkart_reviews(product_url, num_pages):
    all_reviews = []
    for page in range(1, num_pages + 1):
        url = f"{product_url}&page={page}"
        reviews = scrape_reviews(url)
        if not reviews:
            break
        all_reviews.extend(reviews)
        time.sleep(1)  # Reduced delay to 1 second
    return all_reviews

# Product URL and number of pages to scrape
product_url = 'https://www.flipkart.com/wipro-gd203-heavy-weight-1200-w-dry-iron/product-reviews/itm73706d23adb97?pid=IRNGHJ3ZYXDVXGGE&lid=LSTIRNGHJ3ZYXDVXGGESKXJ0P&marketplace=FLIPKART'
num_pages = 10

# Scrape reviews from Flipkart
all_reviews = scrape_flipkart_reviews(product_url, num_pages)

if not all_reviews:
    print("Error: No reviews found.")
    exit()

# Create a DataFrame to store the reviews
data = pd.DataFrame({'review': all_reviews})

# Perform sentiment analysis on the reviews
data['polarity'] = data['review'].apply(lambda review: sentiment_vader(review))

# Calculate overall sentiment
overall_sentiment = data['polarity'].value_counts().idxmax()

# Generate a single suggestion based on overall sentiment
suggestion = generate_single_suggestion(overall_sentiment)

# Plot the sentiment distribution
plt.figure(figsize=(8, 6))
data['polarity'].value_counts().plot(kind='bar', color=['green', 'red', 'blue'], alpha=0.7)
plt.title('Sentiment Distribution of Reviews')
plt.xlabel('Sentiment')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.ylim(0, len(data))
plt.text(0, len(data) * 0.9, f'Suggestion: {suggestion}', fontsize=12, bbox=dict(facecolor='white', alpha=0.5))
plt.tight_layout()
plt.show()


produce the graph and give suggestion in above the graph in one line
--------------------------------------------------------------------------

import requests
from bs4 import BeautifulSoup
import pandas as pd
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import emoji
import time
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.decomposition import LatentDirichletAllocation

# Download the VADER lexicon if not already downloaded
nltk.download('vader_lexicon')

# Function to preprocess text (convert emojis to text representations)
def preprocess_text(text):
    return emoji.demojize(text)

# Function to perform sentiment analysis using VADER
def sentiment_vader(text):
    sid = SentimentIntensityAnalyzer()
    polarity_scores = sid.polarity_scores(text)
    if polarity_scores['compound'] >= 0.05:
        return "positive"
    elif polarity_scores['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

# Function to generate a single suggestion based on overall sentiment
def generate_single_suggestion(sentiment):
    suggestions = {
        'positive': 'Highly recommended! This product seems to have great feedback.',
        'negative': 'Some customers had issues with this product. Consider reading the negative reviews before making a decision.',
        'neutral': 'Opinions on this product vary. You may want to explore further to make an informed choice.'
    }
    return suggestions.get(sentiment, 'No suggestion')

# Function to extract topics from reviews using Latent Dirichlet Allocation (LDA)
def extract_topics(reviews):
    vectorizer = CountVectorizer(stop_words='english')
    dtm = vectorizer.fit_transform(reviews)
    lda_model = LatentDirichletAllocation(n_components=5, random_state=42)
    lda_model.fit(dtm)
    return lda_model.transform(dtm), vectorizer.get_feature_names_out()

# Function to scrape reviews from a single page
def scrape_reviews(url):
    response = requests.get(url)
    content = response.content
    soup = BeautifulSoup(content, 'html.parser')
    reviews_container = soup.find('div', {'class': '_1YokD2 _3Mn1Gg col-9-12'})
    if reviews_container is None:
        return []
    review_divs = reviews_container.find_all('div', {'class': 't-ZTKy'})
    if not review_divs:
        return []
    reviews = []
    for review_div in review_divs:
        review_text = review_div.get_text().strip()
        preprocessed_text = preprocess_text(review_text)
        reviews.append(preprocessed_text)
    return reviews

# Function to scrape reviews from multiple pages
def scrape_flipkart_reviews(product_url, num_pages):
    all_reviews = []
    for page in range(1, num_pages + 1):
        url = f"{product_url}&page={page}"
        reviews = scrape_reviews(url)
        if not reviews:
            break
        all_reviews.extend(reviews)
        time.sleep(1)  # Reduced delay to 1 second
    return all_reviews

# Product URL and number of pages to scrape
product_url = 'https://www.flipkart.com/wipro-gd203-heavy-weight-1200-w-dry-iron/product-reviews/itm73706d23adb97?pid=IRNGHJ3ZYXDVXGGE&lid=LSTIRNGHJ3ZYXDVXGGESKXJ0P&marketplace=FLIPKART'
num_pages = 10

# Scrape reviews from Flipkart
all_reviews = scrape_flipkart_reviews(product_url, num_pages)

if not all_reviews:
    print("Error: No reviews found.")
    exit()

# Create a DataFrame to store the reviews
data = pd.DataFrame({'review': all_reviews})

# Perform sentiment analysis on the reviews
data['polarity'] = data['review'].apply(lambda review: sentiment_vader(review))

# Perform topic extraction using LDA
topic_probabilities, feature_names = extract_topics(data['review'])

# Calculate overall sentiment
overall_sentiment = data['polarity'].value_counts().idxmax()

# Generate a single suggestion based on overall sentiment
suggestion = generate_single_suggestion(overall_sentiment)

# Plot the sentiment distribution
plt.figure(figsize=(8, 6))
data['polarity'].value_counts().plot(kind='bar', color=['green', 'red', 'blue'], alpha=0.7)
plt.title('Sentiment Distribution of Reviews')
plt.xlabel('Sentiment')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.ylim(0, len(data))
plt.text(0, len(data) * 0.9, f'Suggestion: {suggestion}', fontsize=12, bbox=dict(facecolor='white', alpha=0.5))
plt.tight_layout()
plt.show()
   

used topic extractor
-----------------------------------------------------------------

      structure to store 

project-python/
│
├── static/
│   ├── css/
│   │   └── style.css
│   └── js/
│       └── script.js
│
├── templates/
│   └── index.html
│
├── app.py
│
└── requirements.txt



                 style.css

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f0f0f0;
}

header {
  background-color: #333;
  color: #fff;
  padding: 20px;
  text-align: center;
}

main {
  padding: 20px;
}

#input-section,
#results-section {
  background-color: #fff;
  padding: 20px;
  margin-bottom: 20px;
  border-radius: 8px;
}

input[type="text"],
input[type="number"],
button {
  margin-bottom: 10px;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  width: 100%;
}

button {
  background-color: #333;
  color: #fff;
  cursor: pointer;
}

button:hover {
  background-color: #555;
}

#loading-section {
  display: none;
  text-align: center;
}

.spinner {
  border: 8px solid rgba(0, 0, 0, 0.1);
  border-left-color: #333;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

#sentiment-chart-container {
  margin-bottom: 20px;
}

#suggestion {
  font-style: italic;
  text-align: center;
  overflow: auto;
  max-height: 100px;
  padding: 10px;
}

footer {
  position: fixed;
  bottom: 0;
  width: 100%;
  background-color: #333;
  color: #fff;
  text-align: center;
  padding: 10px;
  z-index: 1;
}


           script.js

document.addEventListener("DOMContentLoaded", function () {
  const analyzeBtn = document.getElementById("analyze-btn");
  const loadingSection = document.getElementById("loading-section");
  const resultsSection = document.getElementById("results-section");
  const sentimentChart = document.getElementById("sentimentChart");
  const suggestion = document.getElementById("suggestion");

  analyzeBtn.addEventListener("click", function () {
    const productUrl = document.getElementById("product-url").value;
    const numPages = document.getElementById("num-pages").value;

    loadingSection.style.display = "block";
    resultsSection.style.display = "none";

    $.ajax({
      url: "/analyze-sentiment",
      type: "POST",
      contentType: "application/json",
      data: JSON.stringify({
        productUrl: productUrl,
        numPages: numPages,
      }),
      success: function (data) {
        const positiveCount = data.positive || 0;
        const negativeCount = data.negative || 0;
        const neutralCount = data.neutral || 0;

        sentimentChart.innerHTML = `<p>Sentiment Analysis Results:</p>
                    <ul>
                        <li>Positive: ${positiveCount}</li>
                        <li>Negative: ${negativeCount}</li>
                        <li>Neutral: ${neutralCount}</li>
                    </ul>`;

        new Chart(sentimentChart, {
          type: "bar",
          data: {
            labels: ["Positive", "Negative", "Neutral"],
            datasets: [
              {
                label: "Sentiment Analysis",
                backgroundColor: ["green", "red", "blue"],
                data: [positiveCount, negativeCount, neutralCount],
              },
            ],
          },
          options: {
            legend: { display: false },
            title: {
              display: true,
              text: "Sentiment Analysis",
            },
            scales: {
              yAxes: [
                {
                  ticks: {
                    beginAtZero: true,
                  },
                },
              ],
            },
          },
        });

        const overallSentiment = getOverallSentiment(data);
        suggestion.textContent = generateSuggestion(overallSentiment);

        loadingSection.style.display = "none";
        resultsSection.style.display = "block";
      },
      error: function (error) {
        console.error("Error:", error);
      },
    });
  });

  function getOverallSentiment(sentimentData) {
    const totalReviews =
      (sentimentData.positive || 0) +
      (sentimentData.negative || 0) +
      (sentimentData.neutral || 0);
    const positivePercentage =
      ((sentimentData.positive || 0) / totalReviews) * 100;
    const negativePercentage =
      ((sentimentData.negative || 0) / totalReviews) * 100;

    if (positivePercentage > 60) {
      return "positive";
    } else if (negativePercentage > 40) {
      return "negative";
    } else {
      return "neutral";
    }
  }

  function generateSuggestion(sentiment) {
    const suggestions = {
      positive:
        "Based on the positive sentiment of the reviews, this product seems to be well-received by customers. You can confidently consider purchasing it.",
      negative:
        "The negative sentiment in the reviews indicates some issues with this product. It's advisable to read the negative reviews carefully before making a decision.",
      neutral:
        "The reviews for this product have mixed sentiments, indicating varying experiences. It's recommended to explore further and consider individual factors before deciding.",
    };
    return suggestions[sentiment];
  }
});


           index.html

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sentiment Analysis Web App</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="{{ url_for('static', filename='css/style.css') }}"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  </head>
  <body>
    <header>
      <h1>Sentiment Analysis Web App</h1>
    </header>
    <main>
      <section id="input-section">
        <label for="product-url">Product URL:</label>
        <input type="text" id="product-url" placeholder="Enter product URL" />
        <label for="num-pages">Number of Pages:</label>
        <input
          type="number"
          id="num-pages"
          min="1"
          max="10"
          placeholder="Enter the count of pages"
        />
        <button id="analyze-btn">Analyze Reviews</button>
      </section>
      <section id="loading-section">
        <div class="spinner"></div>
        <p>Loading reviews...</p>
      </section>
      <section id="results-section">
        <div id="sentiment-chart-container">
          <canvas id="sentimentChart" width="500" height="200"></canvas>
        </div>
        <div id="suggestion" style="overflow: auto"></div>
      </section>
    </main>
    <footer>
      <p>&copy; 2024 Sentiment Analysis Web App</p>
    </footer>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
  </body>
</html>


        app.py

from flask import Flask, request, jsonify, render_template
import requests
from bs4 import BeautifulSoup
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import emoji
import time

app = Flask(__name__)

# Download the VADER lexicon if not already downloaded
nltk.download('vader_lexicon')

# Function to preprocess text (convert emojis to text representations)
def preprocess_text(text):
    return emoji.demojize(text)

# Function to perform sentiment analysis using VADER
def sentiment_vader(text):
    sid = SentimentIntensityAnalyzer()
    polarity_scores = sid.polarity_scores(text)
    if polarity_scores['compound'] >= 0.05:
        return "positive"
    elif polarity_scores['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

# Function to scrape reviews from a single page
def scrape_reviews(url):
    response = requests.get(url)
    content = response.content
    soup = BeautifulSoup(content, 'html.parser')
    reviews_container = soup.find('div', {'class': '_1YokD2 _3Mn1Gg col-9-12'})
    if reviews_container is None:
        return []
    review_divs = reviews_container.find_all('div', {'class': 't-ZTKy'})
    if not review_divs:
        return []
    reviews = []
    for review_div in review_divs:
        review_text = review_div.get_text().strip()
        preprocessed_text = preprocess_text(review_text)
        reviews.append(preprocessed_text)
    return reviews

# Function to scrape reviews from multiple pages
def scrape_flipkart_reviews(product_url, num_pages):
    all_reviews = []
    for page in range(1, num_pages + 1):
        url = f"{product_url}&page={page}"
        reviews = scrape_reviews(url)
        if not reviews:
            break
        all_reviews.extend(reviews)
        time.sleep(1)  # Reduced delay to 1 second
    return all_reviews

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/analyze-sentiment', methods=['POST'])
def analyze_sentiment():
    data = request.get_json()
    product_url = data['productUrl']
    num_pages = int(data['numPages'])

    # Scrape reviews from Flipkart
    all_reviews = scrape_flipkart_reviews(product_url, num_pages)

    if not all_reviews:
        return jsonify({"error": "No reviews found"})

    # Perform sentiment analysis on the reviews
    sentiment_data = {"positive": 0, "negative": 0, "neutral": 0}
    for review in all_reviews:
        sentiment = sentiment_vader(review)
        sentiment_data[sentiment] += 1

    return jsonify(sentiment_data)

if __name__ == '__main__':
    app.run(debug=True)


      Sentiment Analysis Web App

it produces bar graph and suggestion 
---------------------------------------------------------------------------

overall view for web app

The sentiment analysis web app is designed to analyze the sentiment of customer reviews for a given product URL on the Flipkart platform. Here's an overview of its functionality and structure:

1. **Input Section**: 
   - Users can input the product URL and specify the number of pages of reviews to analyze.
   - An "Analyze Reviews" button triggers the sentiment analysis process.

2. **Loading Section**:
   - Displays a loading spinner while reviews are being fetched and analyzed.

3. **Results Section**:
   - Displays the sentiment analysis results in the form of a bar chart and a suggestion based on the overall sentiment.
   - The bar chart visually represents the distribution of positive, negative, and neutral sentiments among the reviews.
   - The suggestion provides guidance to users based on the overall sentiment analysis.

4. **Functionality**:
   - Upon clicking the "Analyze Reviews" button, the web app makes a POST request to the Flask backend.
   - The Flask backend scrapes reviews from the specified product URL on Flipkart and performs sentiment analysis using the VADER library.
   - Sentiment analysis results (positive, negative, neutral counts) are returned to the frontend.
   - The frontend dynamically updates the sentiment chart and displays a suggestion based on the overall sentiment.

5. **Technologies**:
   - Backend: Flask framework with Python for server-side processing and sentiment analysis.
   - Frontend: HTML, CSS, and JavaScript for user interface design and interaction.
   - Libraries: jQuery for AJAX requests and Chart.js for rendering the sentiment chart.

6. **Scalability**:
   - The web app can handle varying numbers of reviews by allowing users to specify the number of pages to analyze.
   - It can be scaled further by optimizing the scraping process for large datasets and implementing caching mechanisms for improved performance.

7. **User Experience**:
   - The web app provides a simple and intuitive interface for users to input the product URL and view sentiment analysis results.
   - Feedback on the sentiment of customer reviews helps users make informed decisions about purchasing products on Flipkart.

Overall, the sentiment analysis web app combines backend processing with frontend visualization to provide users with valuable insights into customer sentiments regarding specific products on the Flipkart platform.









             app.py

from flask import Flask, request, jsonify, render_template
import requests
from bs4 import BeautifulSoup
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import emoji
import time

app = Flask(__name__)

# Download the VADER lexicon if not already downloaded
nltk.download('vader_lexicon')

# Function to preprocess text (convert emojis to text representations)
def preprocess_text(text):
    return emoji.demojize(text)

# Function to perform sentiment analysis using VADER
def sentiment_vader(text):
    sid = SentimentIntensityAnalyzer()
    polarity_scores = sid.polarity_scores(text)
    if polarity_scores['compound'] >= 0.05:
        return "positive"
    elif polarity_scores['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

# Function to scrape reviews from a single page
def scrape_reviews(url):
    response = requests.get(url)
    content = response.content
    soup = BeautifulSoup(content, 'html.parser')
    reviews_container = soup.find('div', {'class': '_1YokD2 _3Mn1Gg col-9-12'})
    if reviews_container is None:
        return []
    review_divs = reviews_container.find_all('div', {'class': 't-ZTKy'})
    if not review_divs:
        return []
    reviews = []
    for review_div in review_divs:
        review_text = review_div.get_text().strip()
        preprocessed_text = preprocess_text(review_text)
        reviews.append(preprocessed_text)
    return reviews

# Function to scrape reviews from multiple pages
def scrape_flipkart_reviews(product_url, num_pages):
    all_reviews = []
    for page in range(1, num_pages + 1):
        url = f"{product_url}&page={page}"
        reviews = scrape_reviews(url)
        if not reviews:
            break
        all_reviews.extend(reviews)
        time.sleep(0.05)  # Reduced delay to 1 second
    return all_reviews

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/analyze-sentiment', methods=['POST'])
def analyze_sentiment():
    data = request.get_json()
    product_url = data['productUrl']
    num_pages = int(data['numPages'])

    # Scrape reviews from Flipkart
    all_reviews = scrape_flipkart_reviews(product_url, num_pages)

    if not all_reviews:
        return jsonify({"error": "No reviews found"})

    # Perform sentiment analysis on the reviews
    sentiment_data = {"positive": 0, "negative": 0, "neutral": 0}
    for review in all_reviews:
        sentiment = sentiment_vader(review)
        sentiment_data[sentiment] += 1

    return jsonify(sentiment_data)

if __name__ == '__main__':
    app.run(debug=True)




                              index.html

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sentiment Analysis</title>
    <!-- Include Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='css/style.css') }}"
    />
    <style>
      #sentimentChart {
        width: 300px; /* Adjust width as needed */
        height: 300px; /* Adjust height as needed */
      }
    </style>
  </head>
  <body>
    <h1>Sentiment Analysis</h1>
    <div>
      <form id="sentimentForm">
        <label for="productUrl">Product URL:</label>
        <input
          type="text"
          id="productUrl"
          name="productUrl"
          placeholder="Enter the URL"
          required
        />
        <label for="numPages">Number of Pages:</label>
        <input
          type="number"
          id="numPages"
          name="numPages"
          min="1"
          placeholder="Enter the count"
          required
        />
        <button id="analyze-btn" type="button">Analyze</button>
      </form>
    </div>
    <!-- Add the loading section with the correct ID -->
    <div id="loading-section">
      <div class="spinner"></div>
      <p>Loading reviews...</p>
    </div>
    <!-- Add the results section with the correct ID -->
    <div id="results-section"></div>
    <!-- Add the suggestion section with the correct ID -->
    <div id="suggestion"></div>
    <div>
      <canvas id="sentimentChart" width="300" height="300"></canvas>
    </div>

    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
  </body>
</html>



                        style.css

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f0f0f0;
}

header {
  background-color: #333;
  color: #fff;
  padding: 20px;
  text-align: center;
}

main {
  padding: 20px;
}

#input-section,
#results-section {
  background-color: #fff;
  padding: 20px;
  margin-bottom: 20px;
  border-radius: 8px;
}

input[type="text"],
input[type="number"],
button {
  margin-bottom: 10px;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  width: 100%;
}

button {
  background-color: #333;
  color: #fff;
  cursor: pointer;
}

button:hover {
  background-color: #555;
}

#loading-section {
  display: none;
  text-align: center;
}

.spinner {
  border: 8px solid rgba(0, 0, 0, 0.1);
  border-left-color: #333;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

#sentiment-chart-container {
  margin-bottom: 20px;
}

#suggestion {
  font-style: italic;
  text-align: center;
  overflow: auto;
  max-height: 100px;
  padding: 10px;
  font-size: 20px;
}
#sentimentChart {
  width: 400px; /* Adjust width as needed */
  height: 400px; /* Adjust height as needed */
}

footer {
  position: fixed;
  bottom: 0;
  width: 100%;
  background-color: #333;
  color: #fff;
  text-align: center;
  padding: 10px;
  z-index: 1;
}


                     script.js
document.addEventListener("DOMContentLoaded", function () {
  const analyzeBtn = document.getElementById("analyze-btn");
  const loadingSection = document.getElementById("loading-section");
  const resultsSection = document.getElementById("results-section");
  const sentimentChart = document.getElementById("sentimentChart");
  const suggestion = document.getElementById("suggestion");

  analyzeBtn.addEventListener("click", function () {
    const productUrl = document.getElementById("productUrl").value;
    const numPages = document.getElementById("numPages").value;

    loadingSection.style.display = "block";
    resultsSection.style.display = "none";

    fetch("/analyze-sentiment", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        productUrl: productUrl,
        numPages: numPages,
      }),
    })
      .then((response) => response.json())
      .then((data) => {
        const positiveCount = data.positive || 0;
        const negativeCount = data.negative || 0;
        const neutralCount = data.neutral || 0;

        sentimentChart.innerHTML = ""; // Clear previous chart
        new Chart(sentimentChart, {
          type: "pie",
          data: {
            labels: ["Positive", "Negative", "Neutral"],
            datasets: [
              {
                label: "Sentiment Analysis",
                backgroundColor: ["green", "red", "blue"],
                data: [positiveCount, negativeCount, neutralCount],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false, // This ensures the chart size matches the canvas size
            aspectRatio: 1, // Set the aspect ratio to 1 for a square chart
            plugins: {
              legend: {
                position: "bottom", // Position the legend at the bottom
              },
            },
          },
        });

        const overallSentiment = getOverallSentiment(data);
        suggestion.textContent = generateSuggestion(overallSentiment);

        loadingSection.style.display = "none";
        resultsSection.style.display = "block";
      })
      .catch((error) => {
        console.error("Error:", error);
      });
  });

  function getOverallSentiment(sentimentData) {
    const totalReviews =
      (sentimentData.positive || 0) +
      (sentimentData.negative || 0) +
      (sentimentData.neutral || 0);
    const positivePercentage =
      ((sentimentData.positive || 0) / totalReviews) * 100;
    const negativePercentage =
      ((sentimentData.negative || 0) / totalReviews) * 100;

    if (positivePercentage >= 60) {
      return "positive";
    } else if (negativePercentage >= 40) {
      return "negative";
    } else {
      return "neutral";
    }
  }

  function generateSuggestion(sentiment) {
    const suggestions = {
      positive:
        "Based on the positive sentiment of the reviews, this product seems to be well-received by customers. You can confidently consider purchasing it.",
      negative:
        "The negative sentiment in the reviews indicates some issues with this product. It's advisable to read the negative reviews carefully before making a decision.",
      neutral:
        "The reviews for this product have mixed sentiments, indicating varying experiences. It's recommended to explore further and consider individual factors before deciding.",
    };
    return suggestions[sentiment];
  }
});




output in the form of pie chart
----------------------------------------------------------------------------------










             index.html


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sentiment Analysis</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='css/style.css') }}"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  </head>
  <body>
    <header>
      <div class="header-container">
        <h1>Flipkart Reviews Analysis</h1>
        <p>Get insights from customer reviews</p>
      </div>
    </header>
    <main>
      <section id="input-section">
        <div class="input-field">
          <label for="productUrl"><h3>Product Reviews URL:</h3></label>
          <input
            type="text"
            id="productUrl"
            name="productUrl"
            placeholder="Enter the Flipkart URL"
            required
          />
        </div>
        <button id="analyze-btn" type="button">Analyze</button>
      </section>

      <section id="loading-section" style="display: none">
        <div class="spinner"></div>
        <p>Loading reviews...</p>
      </section>
      <section id="results-section" style="display: none">
        <div id="sentiment-chart-container">
          <canvas id="sentimentChart"></canvas>
        </div>
        <div id="suggestion"></div>
      </section>
    </main>
    <footer>
      <div class="footer-container">
        <p>&copy; 2024 Sentiment Analysis. All rights reserved.</p>
      </div>
    </footer>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
  </body>
</html>


           style.css


body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f0f0f0;
}

header {
  background-color: #333;
  color: #fff;
  padding: 20px;
  text-align: center;
}

main {
  padding: 20px;
}

#input-section,
#results-section {
  background-color: #fff;
  padding: 20px;
  margin-bottom: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Add shadow for depth */
  box-sizing: border-box;
}

input[type="text"],
button {
  margin-bottom: 10px;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  width: 100%;
}

button {
  background-color: #333;
  color: #fff;
  cursor: pointer;
}

button:hover {
  background-color: #555;
}

#loading-section {
  display: none;
  text-align: center;
}

.spinner {
  border: 8px solid rgba(0, 0, 0, 0.1);
  border-left-color: #333;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

#sentiment-chart-container {
  margin-bottom: 20px;
  text-align: center; /* Center text horizontally */
}

#chart-container {
  max-width: 100px; /* Limit maximum width for smaller screens */
}

#suggestion {
  font-style: italic;
  text-align: center;
  overflow: auto;
  max-height: 100px;
  padding: 10px;
  font-size: 20px;
}

#sentimentChart {
  display: block;
  box-sizing: border-box;
  height: 10px;
  width: 150px;
}

footer {
  position: fixed;
  bottom: 0;
  width: 100%;
  background-color: #333;
  color: #fff;
  text-align: center;
  padding: 10px;
  z-index: 1;
}



       script.js


document.addEventListener("DOMContentLoaded", function () {
  const analyzeBtn = document.getElementById("analyze-btn");
  const loadingSection = document.getElementById("loading-section");
  const resultsSection = document.getElementById("results-section");
  const sentimentChart = document.getElementById("sentimentChart");
  const suggestion = document.getElementById("suggestion");

  analyzeBtn.addEventListener("click", function () {
    const productUrl = document.getElementById("productUrl").value;

    loadingSection.style.display = "block";
    resultsSection.style.display = "none";

    fetch("/analyze-sentiment", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        productUrl: productUrl,
      }),
    })
      .then((response) => {
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        return response.json();
      })
      .then((data) => {
        if (data.error) {
          suggestion.textContent = data.error;
          loadingSection.style.display = "none";
          resultsSection.style.display = "block";
          return;
        }

        const positiveCount = data.positive || 0;
        const negativeCount = data.negative || 0;
        const neutralCount = data.neutral || 0;

        sentimentChart.innerHTML = "";
        new Chart(sentimentChart, {
          type: "pie",
          data: {
            labels: ["Positive", "Negative", "Neutral"],
            datasets: [
              {
                label: "Sentiment Analysis",
                backgroundColor: ["green", "red", "blue"],
                data: [positiveCount, negativeCount, neutralCount],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            aspectRatio: 1,
            cutoutPercentage: 50,
            plugins: {
              legend: {
                position: "bottom",
              },
            },
          },
        });

        const overallSentiment = getOverallSentiment(data);
        suggestion.textContent = generateSuggestion(overallSentiment);

        loadingSection.style.display = "none";
        resultsSection.style.display = "block";
      })
      .catch((error) => {
        console.error("Error:", error);
      });
  });

  function getOverallSentiment(sentimentData) {
    const totalReviews =
      (sentimentData.positive || 0) +
      (sentimentData.negative || 0) +
      (sentimentData.neutral || 0);
    const positivePercentage =
      ((sentimentData.positive || 0) / totalReviews) * 100;
    const negativePercentage =
      ((sentimentData.negative || 0) / totalReviews) * 100;

    if (positivePercentage >= 60) {
      return "positive";
    } else if (negativePercentage >= 40) {
      return "negative";
    } else {
      return "neutral";
    }
  }

  function generateSuggestion(sentiment) {
    const suggestions = {
      positive:
        "Based on the positive sentiment of the reviews, this product seems to be well-received by customers. You can confidently consider purchasing it.",
      negative:
        "The negative sentiment in the reviews indicates some issues with this product. It's advisable to read the negative reviews carefully before making a decision.",
      neutral:
        "The reviews for this product have mixed sentiments, indicating varying experiences. It's recommended to explore further and consider individual factors before deciding.",
    };
    return suggestions[sentiment];
  }
});
   

         app.py


from flask import Flask, request, jsonify, render_template
from bs4 import BeautifulSoup
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import requests
import emoji

app = Flask(__name__)

# Download the VADER lexicon if not already downloaded
nltk.download('vader_lexicon')

# Function to preprocess text (convert emojis to text representations)
def preprocess_text(text):
    return emoji.demojize(text)

# Function to perform sentiment analysis using VADER
def sentiment_vader(text):
    sid = SentimentIntensityAnalyzer()
    polarity_scores = sid.polarity_scores(text)
    if polarity_scores['compound'] >= 0.05:
        return "positive"
    elif polarity_scores['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

# Function to scrape reviews from Flipkart
# Function to scrape reviews from multiple pages for Flipkart
def scrape_flipkart_reviews(url, max_pages=10):
    all_reviews = []
    page = 1
    while page <= max_pages:
        response = requests.get(url.format(page))
        content = response.content
        soup = BeautifulSoup(content, 'html.parser')
        review_divs = soup.find_all('div', class_='ZmyHeo')
        if not review_divs:
            break
        reviews = [preprocess_text(review_div.get_text().strip()) for review_div in review_divs]
        all_reviews.extend(reviews)
        page += 1
    return all_reviews


@app.route('/')
def index():
    return render_template('index.html')

@app.route('/analyze-sentiment', methods=['POST'])
def analyze_sentiment():
    data = request.get_json()
    product_url = data['productUrl']

    # Validate URL
    if 'flipkart.com' not in product_url:
        return jsonify({"error": "Invalid URL for Flipkart"})

    # Scrape reviews from the specified URL
    try:
        reviews = scrape_flipkart_reviews(product_url)
    except Exception as e:
        return jsonify({"error": str(e)})

    # Perform sentiment analysis on the reviews
    sentiment_data = {"positive": 0, "negative": 0, "neutral": 0}
    for review in reviews:
        sentiment = sentiment_vader(review)
        sentiment_data[sentiment] += 1

    return jsonify(sentiment_data)

if __name__ == '__main__':
    app.run(debug=True)



produce pie for flipkart product only
--------------------------------------------------